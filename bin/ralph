#!/usr/bin/env node
const { spawnSync } = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");

const rawArgs = process.argv.slice(2);
const args = [];
const cwd = process.cwd();
const repoRoot = path.resolve(__dirname, "..");
const globalDir = path.join(repoRoot, ".agents", "ralph");
const localDir = path.join(cwd, ".agents", "ralph");
const skillsRoot = path.join(repoRoot, "skills");
let agentOverride = null;
let installSkills = false;
let installForce = false;
let prdPath = null;
let planPath = null;
let progressPath = null;
let prdOutPath = null;

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

function usage() {
  console.log(`ralph <command>

Commands:
  install [--skills] [--force]        Copy .agents/ralph into the current repo
  prd "<request>" [--out path]        Generate a PRD via agent
  ping                               Minimal agent health check
  build [n] [--no-commit]             Run build loop (default)
  plan [n]                            Run planning loop
  help                               Show this message

Options:
  --prd <path>                        Override PRD path
  --out <path>                        Override PRD output path (prd command)
  --plan <path>                       Override plan path
  --progress <path>                   Override progress log path
  --agent <codex|claude|droid>        Override agent runner

Notes:
- Uses local .agents/ralph if present; otherwise uses bundled defaults.
- State and logs are written to .ralph/ in the project.
`);
}

for (let i = 0; i < rawArgs.length; i += 1) {
  const arg = rawArgs[i];
  if (arg.startsWith("--agent=")) {
    agentOverride = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--agent") {
    agentOverride = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--skills") {
    installSkills = true;
    continue;
  }
  if (arg === "--force") {
    installForce = true;
    continue;
  }
  if (arg.startsWith("--prd=")) {
    prdPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg.startsWith("--out=")) {
    prdOutPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--prd") {
    prdPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--out") {
    prdOutPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--plan=")) {
    planPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--plan") {
    planPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--progress=")) {
    progressPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--progress") {
    progressPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  args.push(arg);
}

const cmd = args[0];
if (cmd === "help" || cmd === "-h" || cmd === "--help") {
  usage();
  process.exit(0);
}

async function runInstallSkills() {
  const { intro, outro, select, isCancel } = await import("@clack/prompts");
  intro("Ralph skills install");

  const agent = await select({
    message: "Which agent are you using?",
    options: [
      { value: "codex", label: "codex" },
      { value: "claude", label: "claude" },
      { value: "droid", label: "droid" },
    ],
    initialValue: agentOverride || "codex",
  });
  if (isCancel(agent)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const scope = await select({
    message: "Where should skills be installed?",
    options: [
      { value: "local", label: "Local (project)" },
      { value: "global", label: "Global (home directory)" },
    ],
    initialValue: "local",
  });
  if (isCancel(scope)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const home = os.homedir();
  const targetRoot =
    agent === "codex"
      ? scope === "global"
        ? path.join(home, ".codex", "skills")
        : path.join(cwd, ".codex", "skills")
      : agent === "claude"
        ? scope === "global"
          ? path.join(home, ".claude", "skills")
          : path.join(cwd, ".claude", "skills")
        : scope === "global"
          ? path.join(home, ".factory", "skills")
          : path.join(cwd, ".factory", "skills");

  const skillsToInstall = ["commit", "dev-browser", "prd"];
  fs.mkdirSync(targetRoot, { recursive: true });
  const installed = [];
  const skipped = [];

  for (const skill of skillsToInstall) {
    const source = path.join(skillsRoot, skill);
    const target = path.join(targetRoot, skill);
    if (!exists(source)) {
      skipped.push(`${skill} (missing in repo)`);
      continue;
    }
    if (exists(target) && !installForce) {
      skipped.push(`${skill} (already exists)`);
      continue;
    }
    fs.cpSync(source, target, { recursive: true, force: true });
    installed.push(skill);
  }

  if (installed.length) {
    console.log(`Installed skills to ${targetRoot}: ${installed.join(", ")}`);
  }
  if (skipped.length) {
    console.log(`Skipped: ${skipped.join(", ")}`);
  }
  outro("Done.");
}

async function main() {
  if (cmd === "install") {
    if (exists(localDir) && !installForce) {
      console.log(`.agents/ralph already exists at ${localDir}. Skipping templates.`);
    } else {
      if (!exists(globalDir)) {
        console.error(`Bundled templates not found at ${globalDir}.`);
        process.exit(1);
      }
      fs.mkdirSync(path.dirname(localDir), { recursive: true });
      fs.cpSync(globalDir, localDir, { recursive: true, force: true });
      console.log(`Installed .agents/ralph to ${localDir}`);
    }
    const readmeSrc = path.join(repoRoot, "README.md");
    const diagramSrc = path.join(repoRoot, "diagram.svg");
    const imageSrc = path.join(repoRoot, "ralph.webp");
    if (exists(localDir)) {
      const readmeDst = path.join(localDir, "README.md");
      const diagramDst = path.join(localDir, "diagram.svg");
      const imageDst = path.join(localDir, "ralph.webp");
      if (exists(readmeSrc)) fs.copyFileSync(readmeSrc, readmeDst);
      if (exists(diagramSrc)) fs.copyFileSync(diagramSrc, diagramDst);
      if (exists(imageSrc)) fs.copyFileSync(imageSrc, imageDst);
    }
    if (installSkills) {
      await runInstallSkills();
    } else {
      const { confirm, isCancel } = await import("@clack/prompts");
      const wantsSkills = await confirm({
        message: "Install skills (commit + dev-browser + prd)?",
        initialValue: true,
      });
      if (isCancel(wantsSkills)) {
        console.log("Skipped skills install.");
      } else if (wantsSkills) {
        await runInstallSkills();
      }
    }
    process.exit(0);
  }

  const templateDir = exists(localDir) ? localDir : globalDir;
  if (!exists(templateDir)) {
    console.error("No .agents/ralph found locally and no bundled defaults available.");
    process.exit(1);
  }
  if (templateDir === localDir) {
    console.log(`Using local templates: ${localDir}`);
  } else {
    console.log(`Using bundled templates: ${globalDir}`);
  }

  const loopPath = path.join(templateDir, "loop.sh");
  if (!exists(loopPath)) {
    console.error(`loop.sh not found at ${loopPath}`);
    process.exit(1);
  }

  const loopArgs = args.length ? args : ["build"];
  const agentMap = {
    codex: "codex exec --yolo -",
    claude: "claude -p --dangerously-skip-permissions \"$(cat {prompt})\"",
    droid: "droid exec --skip-permissions-unsafe -f {prompt}",
  };
  if (agentOverride) {
    const mapped = agentMap[agentOverride];
    if (!mapped) {
      console.error(`Unknown agent: ${agentOverride}`);
      console.error("Valid values: codex, claude, droid");
      process.exit(1);
    }
    process.env.AGENT_CMD = mapped;
  }
  const env = { ...process.env, RALPH_ROOT: cwd };
  const resolvedPrdPath = prdOutPath || prdPath;
  if (resolvedPrdPath) env.PRD_PATH = resolvedPrdPath;
  if (planPath) env.PLAN_PATH = planPath;
  if (progressPath) env.PROGRESS_PATH = progressPath;
  if (templateDir === globalDir) {
    env.PROMPT_PLAN = path.join(templateDir, "PROMPT_plan.md");
    env.PROMPT_BUILD = path.join(templateDir, "PROMPT_build.md");
    env.ACTIVITY_CMD = path.join(templateDir, "log-activity.sh");
    env.GUARDRAILS_REF = path.join(templateDir, "references", "GUARDRAILS.md");
    env.CONTEXT_REF = path.join(templateDir, "references", "CONTEXT_ENGINEERING.md");
  }

  if (cmd === "ping") {
    const agentCmd = agentOverride ? agentMap[agentOverride] : agentMap.codex;
    if (!agentCmd) {
      console.error("Unknown agent for ping.");
      process.exit(1);
    }
    const agentBin = agentCmd.split(" ")[0];
    const existsResult = spawnSync(`command -v ${agentBin}`, { shell: true, stdio: "ignore" });
    if (existsResult.status !== 0) {
      console.error(`Agent command not found: ${agentBin}`);
      process.exit(1);
    }
    const promptFile = path.join(os.tmpdir(), `ralph-ping-${Date.now()}.txt`);
    fs.writeFileSync(promptFile, "Reply with <end>pong</end> only.");
    const escapePath = (value) => `'${String(value).replace(/'/g, "'\\''")}'`;
    const rendered = agentCmd.includes("{prompt}")
      ? agentCmd.replace(/\{prompt\}/g, escapePath(promptFile))
      : `cat ${escapePath(promptFile)} | ${agentCmd}`;
    const result = spawnSync(rendered, { shell: true, encoding: "utf-8" });
    const output = `${result.stdout || ""}${result.stderr || ""}`;
    if (!output.includes("<end>pong</end>")) {
      console.error("Ping failed: missing <end>pong</end>.");
      process.exit(1);
    }
    console.log("Ping OK.");
    process.exit(0);
  }

  if (cmd === "prd") {
    const request = args.slice(1).join(" ").trim();
    if (!request) {
      console.error("Missing PRD request. Usage: ralph prd \"<request>\" [--out path]");
      process.exit(1);
    }
    const requestFile = path.join(os.tmpdir(), `ralph-prd-${Date.now()}.md`);
    fs.writeFileSync(requestFile, `${request}\n`);
    const prdArgs = ["prd", "--prompt", requestFile];
    const result = spawnSync(loopPath, prdArgs, {
      stdio: "inherit",
      env,
    });
    process.exit(result.status ?? 1);
  }

  const result = spawnSync(loopPath, loopArgs, {
    stdio: "inherit",
    env,
  });

  process.exit(result.status ?? 1);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
